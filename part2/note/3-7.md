## 3-7) 캐시 최적화

- lighthouse 실행한다

- 그러면 lighthouse에 대한 결과가

- DIAGNOSTICS 항목보면 Serve static assets with an efficient cache policy 있다

  - 즉 효율적인 캐시 정책이 적용되어 있지 않다는 뜻

  - 여기서 말하는 static assets은 이미지, 동영상, js, css 같은 것들

- 네트워크 탭에서 Js 파일 보면 Response 헤더에 캐시 관련 설정이 안되어 있는 것을 확인할 수 있다

  - cache-control이라는 헤더가 없다

### 캐시

- '데이터나 값을 미리 복사해 놓는 임시 장소나 그런 동작'

- 크롬 브라우저 기준으로, 브라우저는 크게 두가지 방식으로 캐싱을 한다

  - 메모리 캐시

    - 메모리, 즉, RAM에 데이터를 저장해두는 방식

    - 그리고 캐시로 꺼내 쓴다

  - 디스크 캐시

    - 디스크, 즉, 파일로 저장해 놓는 방식

- 이 두가지는 직접 설정할 수 있는 옵션은 아니고, 사이즈나 빈도에 따라서 브라우저 자체 알고리즘에 따라서 설정된다

- 구글 웹 페이지에서 네트워크 탭에서 disabled cache 끄고 새로침하며느, Size 항목에 memory cache, disk cache 항목 있는 것을 확인할 수 있다

- 브라우저를 완전히 끝 다음에 네트워크 탭 열고 다시 구글에 들어가서 네트워크 탭 보면 모두 disk cache로 데이터를 불러오는 것을 알 수 있다

- memory cache는 RAM에 데이터를 저장하는 방식인데, 브라우저를 완전히 껐다가 켰기 때문에 브라우저가 사용하는 메모리 영역을 날려버렸다

- 그래서 메모리에 저장해주었던 데이터가 다 날라가고 그것을 파일로만 가지고 있었다가 해당 파일에서 캐시를 꺼내서 불러서 사용하고 있는 방식

### Cache-Control

- 캐시를 적용하려면 브라우저가 서버로 특정 리소스를 요청할 때 서버에 해당 리소스에 캐시를 적용해달라는 설정을 해주어야 하는데

- 그것이 Cache-Control이라는 지시문

- http 헤더에 들어간다

- 브라우저가 이미지를 요청하면

  - 서버가 이미지를 보내주는데, 이 이미지에 몇 초 정도 cache를 유지하라고 알려주는데

  - 이 때 알려주는 게 cache-control이라는 지시문

- 이 지시문은 서버에 넣어주는 것이 깨문에 서버 설정이 필요하닥

- webpack dev server가 아닌 실제 빌드된 파일을 서비스 해주는 서버에서 이런 설정을 해주어야 한다

- 크게 다섯가지 항목, 자주 쓰이고 중요하다

- no-cache : 캐시를 사용하기 전에 서버에 검사 후, 사용 결정

  - 다르게 포현하면 max-age=0과 같다

    - max-age가 지났어도 해당 리소스를 완전히 버리는 것이 아니라

    - 만료되었다고 바로 서버에 데이터를 요청해서 받아오는 것이 아니라, 서버에 해당 리소스를 사용해도 되는지 물어본다

    - 그리고 서버는 사용해도 된다고 하던가 또는 안된다고 새로운 리소르를 내려준다

    - 그렇기 때문에 no-cache는 max-age=0과 같다

  - 서버에 이 캐시 사용해도 되는지 물어보고 사용하는 방식

  - 브라우저에 이미지가 캐시가 되어 있는 경우,

  - 서버한테 이 이미지를 사용하려고 하니까 no-cache 있으면 서버에 이 이미지를 캐시로 사용하려고 하는데,

  - 이 이미지가 만료되거나 바뀌었는지 서버에 물어보고

  - 서버가 Ok 사인이 보내지면 그 이미지를 그대로 사용한다

  - 만약에 안된다는 응답 오면 서버로 부터 이미지를 다시 받아오는 방식으로 동작한다

- no-store : 캐시 사용 안 함

- public : 모든 환경에서 캐시 사용 가능

- private : 브라우저 환경에서만 캐시 사용, 외부 캐시 서버에서는 사용 불가

  - 즉, 서비스를 이용하면 내 브라우저에서도 캐싱을 걸지만

  - 중간 중간 거치는 서버에서도 캐시 서버가 따로 있기 때문에 외부 캐시 서버에서는 이 캐싱을 해준다

  - 외부 캐싱 서버에서는 private가 있으면 캐시를 걸지 않는 다는 뜻

  - 예를들어 로그인 해서 나만의 private한 정보가 있는 그런 페이지를 캐시한다고 치면

  - 그런 데이터들을 내 브라우저에서 캐시가 되면 괜찮은데 서버 상에서 다른 사람들과 공유가 되는 그런 캐시 서버에서 캐시가 되면 안되기 때문에 그런 경우에 사용한다

- max-age : : 캐시의 유효시간

  - 가장 중요하다고 볼 수 있다

  - 60이라고 되어 있으면 60초 동안 캐시가 적용되는 것

  - 600이면 600초, 10분 동안 캐시를 한다는 뜻

- 번외로 Etag, Expires라는 헤더 지시문도 있다

- 이러한 캐시 설정은 웹 서버에서 해주는 것이다

- server.js 파일에 서버가 구현되어 있다

- package.json의 script의 serve 명령어로 정의를 해주었다

- npm run serve 하면 빌드되어 있는 디렉토리의 static 파일들을 서비스 해준다

- 그렇기 때문에 그 전에 빌드를 해주어야 한다

```shell

$ npm run build

$ npm run serve

```

- 아래 코드는 아예 캐시를 사용하지 않겠다는 것과 같다

- no store 옵션과 같다

- 하지만 아래 Expires, Pragma와 같은 것 붙인 이유는

- 특정 브라우저 같은 경우, 특히 IE 같은 경우 no-store 옵션 만으로는 캐시 해제가 제대로 되지 않는 경우가 있기 때문에 이렇게 여러 옵션들을 확실하게 붙여주었다

```js
// server/server.js
const header = {
  setHeaders: (res, path) => {
    res.setHeader(
      'Cache-Control',
      'private, no-cache, no-store, must-revalidate'
    );
    res.setHeader('Expires', '-1');
    res.setHeader('Pragma', 'no-cache');
  },
};
```

- 네트워크 탭 확인해서 파일 보면 위에서 설정해준 옵션들이 Response 헤더에 있는 것을 확인할 수 있다

- 아래처럼 max-age 수정 후 다시 serve 명령어로 실행한다

```js
const header = {
  setHeaders: (res, path) => {
    res.setHeader('Cache-Control', 'max-age=20');
    // res.setHeader('Expires', '-1')
    // res.setHeader('Pragma', 'no-cache')
  },
};
```

- 그리고 나서 한번 더 새로고침 한 다음 보면 여러가지 파일들의 Size 항목에서 memory cache, disk cache 있는 것을 확인할 수 있고 Response header에서 max-age 있는 것을 확인할 수 있다

- 20초가 지난 후에 다시 새로고침해서 Size 항목 보면 보통 kb인데 b로 여러 파일들의 굉장히 작은 것을 확인할 수 있다

- 그 이유는 캐시가 만료가 되서 새로 리소스를 받아와야 하는데 매번 이렇게 만료된 다음 리소스를 받아와야 하면 비효율적이니까

- 브라우저가 자체적으로 리소스가 만료가 되었는데 업데이트 해야 되는지 서버에 물어본다

- 그러면 서버에서 수정되지 않아서 사용해도 된다던가 수정 되어서 다시 받아와야 한다고 알려준다

- 만약 사용해도 되면 별도로 다운로드 하지 않고 캐시되어 있는 리소스를 그대로 사용한다

- 그렇기 때문에 리소스를 그대로 다운로드 한 것이 아니라, 응답하는 과정만 거쳤기 때문에 트래픽 사이즈가 굉장히 작게 잡힌 것이다

- 한가지 더 status도 304인데, 리소스가 수정이 되지 않았다는 뜻

- 과연 서버는 우리가 가지고 있는 캐시데이터가 서버에 있는 최신 데이터와 다른지, 다르지 않는 것을 어떻게 알 수 있을까 ?

  - 그 이유는 ETag라는 지시문 때문

  - 네트워크 탭 보면 Response Header에 ETag가 붙어 있다

  - ETag는 해당 리소스에 대한 Hash

  - 브라우저가 어떤 리소스를 가지고 있을 때 서버에서 내려준 ETag를 가지고 있다

  - 만약에 브라우저의 ETag가 AAA, 서버가 가지고 있는 리소스의 ETag가 AAA

  - 그러면 브라우저가 서버에게 이미지를 사용해도 되는지 물어볼 때, 이미지 자체를 보내는 것이 아니라 ETag를 보낸다

  - 서버는 해당 리소스의 ETag를 확인한 다음에 변하지 않았다면 ok를 보내주고

  - 만약 BBB로 ETag가 바뀌었다면 새로 받아야 한다고 브라우저에 알려주는 것이다

- 지금 모든 리소스에 max-age를 20으로 설정해주었다

- ETag 때문에 리소스를 새로 다시 받지 않지만, 네트워크 요청을 한번 더 왔다갔다 해야한다

- 그렇기 때문에 캐시를 바로 사용하는 것 보다는 비효율적이다

- 이미지 같은 일부 리소스는 오랫동안 변하지 않을 것

  - 예를들면 로고나 static image 같은 것들

  - 그렇기 때문에 캐시를 오랫동안 주어도 될 것

  - 리소스 별로 효율적으로 캐시를 주어야 한다

- 기본적으로 캐시는 항상 적용되어져 있어야 좋은데 그래야지 리소스를 매번 부르지 않으니까

- 단, 리소스가 변경되지 않는다는 전제하에

- 만약 브라우저에서 리소스를 하루정도 캐시를 걸고 있는데, 서버에서는 이미지가 바뀌어도 캐시가 걸린 하루 동안은 캐시 이미지만 계속 보여주고 바뀐 이미지를 보여주지 않게 된다

- 브라우저 입장에서는 캐시가 걸려 있으면 최신 정보를 알기 힘들다는 문제가 있다

- 캐시를 사용할 때 최신 데이터를 어떻게 즉각 적용할지를 고민해야 한다

### 리소스 별 캐시 설정

- HTML 파일 로드 되면 script 태그나 style 태그 또는 link 태그를 통해서 JS, CSS 로드를 하게 된다

- 그런 다음 IMG를 호출한다

- 여기에서 HTML 리소스에 대해서 캐시가 적용되었다면 변경사항이 즉각 적용 되지 않는다

- HTML에 새로운 내용으로 수정이 되었는데 캐시가 걸려 있다면 서버의 컨텐의 수정사항을 즉각적으로 반영하지 못하게 된다

- 그렇기 때문에 HTML 리소스 경우 보통 no-cache 옵션을 설정한다

- 그러면 서버에 한번 물어볼테니까 항상 최신 버전으로 리소스를 로드할 수 있다

- no-store를 사용할 수 있지만, 그렇게 되면 항상 HTML파일을 다운로드 받아야 하지만 no-cache 사용하면 변경사항이 없는 경우 새로 리소스를 받지 않아도 되니까 더 효율적이라고 할수 있다

- JS, CSS 파일 같은 경우 HTML처럼 항상 최신으로 유지가 되어있어야 한다

- 하지만 no-cache 설정을 사용하지 않는데, 그 이유는 JS, CSS 리소스 같은 경우 JS는 웹팩으로 번들링되는데 JS는 버저닝을 하기 때문에, 즉, 버전을 위해서 main.sdfadf.js 이런 식으로 해시가 된다

- 즉, 항상 자바스크립트가 수정이 되면 항상 새로운 자바스크립트 리소스를 생성한다

- 그래서 HTML 리소스가 최신으로 유지가 되는한 항상 최신의 자사브크립트 리소스를 요청하게 된다

- 예를들어 main.a.js라는 리소스가 있다고 하자

- HTML에서 main.a.js 파일을 불러왔지만 수정되어서 main.b.js로 변경되었다고 하자

- HTML은 no-cache이기 때문에 js 변경사항도 바로 최신으로 확인할 수 있다

- main.a.js 라면 캐시되어 있는 데이터를 사용했을텐데, main.b.js니까 완전 새로운 데이터를 불러온다

- HTML이 최신으로 유진되니까 항상 최신 js파일을 불러오게 된다

- 그렇기 때문에 똑같은 js 파일을 불러올 일이 없으니까

- js 캐시 설정은 무한대에 가까운 , 일주일 또는 한달에 해당하는 긴 시간을 잡아준다

- CSS도 마찬가지

- 이미지 리소스도 비슷한데, 이미지는 변경되지 않는 경우에는 그냥 캐시를 적용하고 자주 바뀌는 이미지라면 캐시 기간을 짧게 하거나 js나 css 처럼 이미지에 해시를 달아줘서 매번 이미지의 이름이 바뀌는 방식을 적용할 수 있다

- HTML : no-cache

- JS : public, max-age=31536000

  - 1년에 해당하는 값

- CSS : public, max-age=31536000

- IMG : public, max-age=31536000

- 아래처럼 코드를 수정해준다

```js
const header = {
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache');
    } else if (
      path.endsWith('.js') ||
      path.endsWith('.css') ||
      path.endsWith('.webp')
    ) {
      res.setHeader('Cache-Control', 'public, max-age=31536000');
    } else {
      res.setHeader('Cache-Control', 'no-store');
    }
  },
};
```

---

### Q. 프론트엔드 쪽 cache-control

- fetch나 axios 에서 요청을 보낼 때, cache-control 설정해서 요청하는거랑

- 서버에서 설정해서 보내주는거랑 무슨 차이인가요?

### A.request header에 붙는 cache-control 지시문에 대해서 질문을 주셨는데요,

- 일반적으로 cache-control은 response header에 붙는 것이 맞습니다.

- 다만, 특정 캐시 동작(ex: 서버 및 중간 프록시 서버에서 유효성 재확인 등)을 지정하기 위해 클라이언트에서도 request header에 cache-control 지시문을 붙여서 전송할 수 있습니다.

- 이 때, request header에 들어가는 cache-control의 값은 response header와는 조금 다른데,

- 다음 문서에서 그 내용을 확인하실 수 있습니다.

  - [Cache-Control - mdn](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control#%EC%BA%90%EC%8B%9C_%EC%9A%94%EC%B2%AD_%EB%94%94%EB%A0%89%ED%8B%B0%EB%B8%8C)

<br/>

### Q. private로 설정하면

- AWS S3에서 올라간 이미지들을 불러올 때 캐싱이 적용이 안되는건가요 ? 내 브라우저 기준이 어떤건지 잘 모르겠습니다.

### A. private 설정을 하면 브라우저에서만 캐싱이 적용되는데, 여기서 말하는 브라우저란, 말 그대로 유저단의 클라이언트를 의미합니다. (크롬, IE, 사파리 등등)

- (즉, 중간 CDN에서는 캐시가 적용되지 않습니다.)

  - 참고: https://aws.amazon.com/ko/premiumsupport/knowledge-center/prevent-cloudfront-from-caching-files/

<br/>

### Q. 번외지만 배포에대해 궁금한점이 있습니다.

- 지금 강의 예제로 사용하는 프로젝트와 같이 서버와 클라이언트 코드가 같이 있는 경우에는 어떻게 배포해야하는지 궁금합니다.

- 개발할때는 npm run serve 와 같이 수동으로 서버를 켜서 작동시킬 수 있지만 그렇지 않을때는 어떻게 작동시킬 수 있나요?

- 실제로는 서버용 레포, 클라용 레포 따로 개발해서 배포해야하는 건가요?

### A. 수동으로 서버를 켜서 작동시킨다는 부분이 무슨 의미인가요?

- 기본적인 배포에 대해서 설명을 드리면,

- 프론트엔드 코드를 배포할 때는 build된 파일(번들파일)만 배포하면 됩니다.

- 이것을 배포하는 방법에도 다양한 방법이 있는데요,

- 일반적으로 서버에 index.html 파일을 올리고 nginx로 서빙을 해줍니다.

- 그 외 기타 js나 css 파일은 S3와 같은 CDN에 올리기도 하고 아니면 그냥 html과 동일하게 nginx로 서빙해줄 수 있습니다.

<br/>

### Q. 수업듣고 사이트를 보다가 궁금한점이 생겼는데요~

- 질문1.

  - HTML 상단 메타태그에 <meta http-equiv="Cache-Control" content="no-cache"> 를 주면 서버에서 설정하지 않아도

  - 예제에서 사용한거랑 같이 해당 HTML이 변경될 때만 다운로드할까요 ?

  - (이러면 request header의 캐시컨트롤에 노캐시가 붙나요?)

- 질문2.

  - 예제에선 HTML을 제외하고 CSS JS Image의 max-age를 길게주고 소스 변경시에만 hash를 다르게 붙여 변경된 리소스만 새 파일을 다운로드 하게 했는데요

  - HTML CSS JS Image를 모두 no-cache로 주면 어떻게 작동할까요 ?

### A.

- 질문1.

  - 그건 해당 지시문에 대해서는 정확히 모르겠지만,

  - 문서 내용을 찾아보면 http 헤더와 동일한 역할을 한다고 합니다.

    - (https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta)

  - 다만, 해당 meta 태그를 입력했다고 http header가 변경되지는 않을 겁니다.

- 질문2.

  - css, js를 no-cache로 주면 매번 해당 파일이 변경되었는지(캐시에 있는 데이터를 사용해도 되는지)를 서버에 물어봅니다.(html과 동일)

  - 하지만, css, js의 경우 변경이 되면 해시가 변경되면서 파일 이름 자체가 변경되기 때문에 굳이 no-cache로 사용할 필요는 없겠죠?

  - image의 경우도 동일합니다.
