## 3-8) 불필요한 css 제거

- npm run serve 후, lighthouse 실행한다

- Opportunities 항목보면 Remove unused CSS 항목 있다

- 말 그대로 사용하지 않는 CSS 제거해서 성능을 높이라는 뜻

- 현재 main.dsfadf.chunk.css 사용하고 있는데, 이 중에서 사용하지 않는 css를 제거하면 얼마나 아낄 수 있는지 보여주고 있다

- lighthouse 창에서 Esc 누르면 아래 창이 나타나는데 거기서 Coverage 탭을 확인한다

- 우리가 실질적으로 사용하는 코드의 비율을 보여준다

- 빨간색 부분이 사용하고 있지 않는 코드의 양

- 코드 클릭하면 Source 탭으로 이동하는데, 왼쪽 라인 넘버 쪽에 빨간색 또는 파란색 막대가 있는 것을 확인할 수 있다

- 파란색은 지금 우리가 실행하고 실질적으로 서비스에서 사용하고 있다는 뜻

- 빨간색은 서비스에서 사용하고 이씾 않다. 읽은 적이 없다는 뜻

- 굉장히 많은 영역이 빨간색인 것을 확인할 수 있다

- 이 부분을 빼면 bundle 사이즈가 줄어들 수 있다

- 사용하지 않는 빨간색 코드 제거하는 방법여러가지 있지만 [PurgeCSS](https://purgecss.com/) 사용한다

- PurgeCSS는 간단히 말하면 HTML, JS등 static 파일에 있는 문자열들을 다 추출해서 css에 있는 클래스 이름과 비교 한다

- 그래서 만약에 이 css에 있는 클래스 이름이 static한 HTML, JS에 문자열에 포함되어 있지 않다면 해당 클래스를 제거하게 된다

- tailwind.css에서 sponsor하고 있는데, [tailwind optimization](https://tailwindcss.com/docs/optimizing-for-production)에서 확인할 수 있다

  - PurgeCSS가 static한 파일을 각 문자열마다 잘라서 구분해서 읽게 되고,

  - css의 클래스 이름과 비교해서 만약에 위에서 추출된 문자열에 클래스 이름이 포함되어 있지 않다면 해당 클래스 이름은 제거한다

  - 예를들어 test123 이라는 클래스가 사용되고 있다면 파일에 test123 해당하는 이름이 있는지 확인하고 없다면 test123라는 이름을 PurgeCSS에서 제거한다

  - 단점을 꼽자면 class 이름 이외에도 href, 그래서 태그 안에 있는 문자열 또한 클래스와 비교를 하기 때문에

  - 만약 `.href`라는 클래스 이름이 있다면, 해당 클래스를 사용하지 않더라도 href 속성을 가진 요소를 남겨둘 수 가 있게 된다

  - 현재는 확인할 수 없는 것 같음

- 여기서는 커맨드라인으로 하지만 ,Next.js, React등에서 플러그인을 추가하는 방식을 제공해주기도 한다

```shell

$ npm i --save-dev purgecss

```

- purgeCSS에 대한 명령을 실행하는 스크립트를 아래처럼 작성한다

```json

    "purge": "purgecss -css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js/*.js"

```

- build/static/css에 있는 파일들에 대해서 purge하고 output을 동일한 폴더로 내보내서 같은 이름으로 덮어쓰겠다는 뜻

- --content 명령어는 어떤 파일들과 비교할 건지를 정하는 것

```shell

$ npm run purge

```

- purge 명령어 실행 후 build/static/css의 `.css`파일 보면 이전과 달리 굉장히 짧아진 것을 확인할 수 있다

- 다시 build 한 다음 serve 명령어 실행 후 네트워크 탭에서 main.19625a18.css 파일 보면 크기가 이전에 비해 현재 굉장히 줄어든 것을 확인할 수 있다

  - 파일 사이즈는 해보니까 약간씩은 다르다

- 아까 lighthouse에서 줄일 수 있다고 한 것 만큼 줄어들지 않고 그 보다는 더 큰데

- 그 이유는 Coverage 탭에서 확인해보면 아직까지 사용되지 않는 영역이 꽤 있기 때문

- 아무래도 purge가 정확한 클래스 이름만 뽑아서 비교하는 것이 아니라 static한 파일의 모든 문자열에 대해서 비교하기 때문이다

- 굉장히 작은 부분이기 때문에 이러한 것 까지 없애고 싶으면 나중에 찾아볼 것

- 그리고 페이지 이동하게 되면 Unused Bytes가 계속해서 줄어드는 것을 확인할 수 있는데

- 이것은 조금씩 클래스를 읽고 있다는 뜻이다

- 즉, 메인페이지에서 사용하지 않았던 스타일들을 다른 페이지에서는 사용하게 되니까 사용되지 않는 바이트 수가 줄어들게 되는 것

- 여기서 문제는, 메인 페이지 들어가 보면 스타일이 제대로 적용되지 않는 현상이 나타난다는 것이다

- 예를들어 비디오 아래 이미지 3장 한 줄에서 보이는데 지금은 각각 세로로 이미지가 보인다

- 그 이유는 `lg:m-8`이라는 클래스가 이름만 있고 스타일이 적용되지 않았기 때문

- 이렇게 적용되지 않는 이유는 `lg:m-8` 그대로 문자열을 검사했어야 했는데, purge가 lg와 m-8 이런식으로 짤라서

- lg따로 m-8 이렇게 따로 읽었기 때문에 이렇게 `lg:m-8`이라는 전체 문자열이 포함이 되지 않은 것이다

- 이것을 purgeCSS의 config에서 설정을 해주어야 한다

- purgeCSS의 Configuratoin 항목들어가 보면 defaultExtractor 라는 것이 있는데

  - 이것은 static한 파일을 읽을 때 어떠한 정규식으로 읽을 것인지, 어떠한 패턴으로 문자열을 읽을지 결정하는 함수 옵션

- purgecss.config.js파일 만들고 아래 내용을 넣어준다

```js
module.exports = {
  defaultExtractor: (content) => content.match(/[\w\:\-]+/g) || [],
};
// content는 파일에 대한 string 값으로 위의 스크립트에서 --content 옵션을 통해 지정한 파일의 문자열을 그대로 읽은 값
// 정규식으로 읽은 다음에 배열로 리턴하게 된다
// \w - [0-9a-zA-Z_]와 같다, 언더바까지 포함
// 여기에 콜론과 하이픈 추가하고 여러개 있다는 것(+)을 사용해서 표현한 정규식
```

- 그리고 아래처럼 스크립트도 수정해준다

```json

"purge": "purgecss --css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js/*.js --config ./purgecss.config.js"

```

- 다시 purge, build 후 serve 명령어 실행하면 스타일 깨지지 않고 정상적으로 스타일 적용된 것을 확인할 수 있다

---

### Q.

- 불필요한 css를 purgecss로 제거하셨는데,

- 궁금한 점이 웹앱의 경우는 웹에서 사용하는 css는 앱에선 필요없고,

- 앱에서 사용하는 css는 웹에서는 필요없는데 이런것도 구별해서 제공을 해주는지 궁금합니다.

- 웹앱의 경우는 두개의 css를 다 갖고 있어서 불필요한 css를 줄일 수 있는지가 궁금합니다.

### A. PC와 모바일 환경에 따른 CSS 포함 여부에 대해서 질문을 주셨는데요,

- 말씀하신 부분은 일반적인 반응형 웹 방식의 문제점이라고 할 수 있습니다.

- 기기 환경에 따라 각각의 스타일을 모두 보유하고 있어야 한다는 단점이죠.

- 그래서 일부 서비스들은 그 둘의 환경을 구분합니다.

  - (ex - https://www.naver.com vs https://m.naver.com)

- 그래야 말씀하신 것 처럼 당장의 기기 환경에서 필요없는 스타일을 구분해 낼 수 있으니까요. (단순 CSS 뿐만 아니라 JS도 마찬가지 입니다.)

- 만약 이렇게 이렇게 두 개의 환경을 구분하여 서비스하지 않고 반응형으로 서비스를 한다고 하더라도 환경에 따른 리소스를 구분해서 로드할 수는 있습니다.

- user agent나 클라이언트 단에서 기기의 가로 사이즈를 통해 판단할 수도 있겠죠.

- 중요한 건 말씀하신 것처럼 각 환경에 따라 스타일이나 기능이 다르다면 분명히 다른 환경에 대한 코드, 즉, 당장 필요없는 코드들이 포함되어 로드가 될 수 있다라는 것이고,

- 서비스의 특징, 환경에 따라 적절하게 타협을 하거나 다양한 기법들(PC와 모바일 사이트 분리, 환경에 따른 리소스 동적 로드 등)을 생각해볼 수 있을 것 같습니다.

<br/>

### Q. 캐시 최적화 강의를 보고 난 뒤에 궁금증이 생겼습니다

- app.use(express.static(path.join(\_\_dirname, "../build"), header));

- 를 통해 빌드된 것들에 대해 해더를 적용하는 것으로 이해했습니다.

- 근데 이렇게 빌드 된 것이 아니라 FE, BE 따로 나뉘어서 배포되어 서로 다른 도메인인 경우 어떻게 해야 하나요?

- BE는 static 자료가 없이 api만 보내는 기능을 하고 FE는 vercel이나 netlify 또는 다른 EC2로 배포되어 있는 경우를 말씀드립니다.

- app.use(header);

- 이렇게 하면 될까 했지만 이건 에러를 뱉어냅니다

### Q. FE 코드를 어떻게 서비스하냐에 따라 달라질 것 같습니다.

- 일반적으로 Static 파일로 빌드를 하고 CDN에 올려서 서비스를 합니다.

- 이런 경우 CDN이 실질적인 서버가 되므로 CDN 설정을 통해 캐시 설정을 할 수 있습니다.

- 자세히는 모르겠지만, netlify나 vercel 같은 경우도 찾아보면 캐시를 설정할 수 있는 옵션이 있을 것으로 보입니다.
